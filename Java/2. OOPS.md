Data first, Logic later
# Encapsulation
Informaton Hiding


# Constructor
  * It has same name as class.
  * A class can have more than one constructor.
  * It can have zero or more parameter.
  * It doesn't return value.
  * It can only be called with new operator.

# Implicit & Explicit parameter
  public void foo(number) {
    System.out.printLn(this.number + number)
  }
  this.number = 10;
  this.foo(55) // 65
  here two parameter are passed.
  #### Explicit parameter
    55 is explicit parameter
  #### Implicit Parameter
    this is impliit parameter as instanc eis passed and it use number variable of this instance.

# Public/Private/Final/

# Static
  There is one static field per class.
    Static -> Exposed the fn/var to JVM
    Static field has single instance.
    If 100 instance of a class is created, static instance is still only one and belongs to class, not individual object
    Static method are kind of those method who doesn't have any imlicit parameter e.g -> math.pow(x,y) i.e doesnot have this parameter

# Setter/Getter method should return cloned data as sending same data will break encapsulation


# Constructors
 ## Overloading
 It means multiple fn avaible with same name with different parameter.
 Which fn will call is based on the number of parameter passed.

 To initialize some data before constructor is called define those in root of main fn/outside of constructor
  ## Call another constructor from constructor
  this("param1", "param2") // inside constructor.

  ## Initialization Blocks
    class Employee {
      private static int nextId;
      private int id;
      // Initialization block, didn't depend on any constructor
        {
          id = nextId;
          nextId++;
        }
    }

  # Static Imports
    import static java.lang.System.*;
    // We can use 
    out.println("Goodbye, World!"); // i.e., System.out
    exit(0); // i.e., System.exit

  # Coding Standard Hints
    * Keep data always private as this violated encapsulation
    * Always initialize data(not depend in default value)
    * Not use too manu basic types with other class(create reusable class)
    * Not all field are required getter /setter function
    * Break classes having too much responsibility
    * Use meaningful naming convention
    * Prefer immutable classes


# Inheritance
  * Classes
  * SuperClasses - > Parent class
  * SubClasses - > Class which inherit super class

  ## Overriding Methods
    Since variable are private so we can't access the variable
    So first we call superclass function first and get result of that and then implement our logic.

    ```java
      public double getSalary() {
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
      }
    ```
    ## Call super class constructor
      ```java
        public Manager(String name, double salary, int year, int month, int day) {
          super(name, salary, year, month, day);
          bonus = 0;
        }
      ```
  # Polymorphism
  ```java
    Manager boss = new Manager(. . .);
    Employee[] staff = new Employee[3];
    staff[0] = boss;
    // In this case, the variables staff[0] and boss refer to the same object. However, staff[0] is considered to be only an Employee object by the compiler.
    // That means you can call
    boss.setBonus(5000); // OK
    // but you canâ€™t call
    staff[0].setBonus(5000); // Error
    // bcoz The declared type of staff[0] is Employee, and the setBonus method is not a method of the Employee class.
  ```

  arrays of subclass references can be converted to arrays of superclass references without a cast. For example, consider this array of managers:
  